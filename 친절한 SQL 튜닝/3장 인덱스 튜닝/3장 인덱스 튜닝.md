# 3.1 테이블 액세스 최소화
## 3.1.1 테이블 랜덤 액세스
### 인덱스에 대한 맹신 또는 섣부른 자신감
- 아무리 데이터가 많아도 인덱스 사용하면 데이터가 금방 조회
- 대량 데이터를 조회할 때 인덱스를 사용하면 테이블 전체 스캔 보다 훨씬 느림
### 인덱스 ROWID는 물리적 주소? 논리적 주소?
인덱스 ROWID는 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보,
테이블 레코드와 물리적 직접 연결된 구조가 아니다.
또한 캐시에 올라가더라도 메모리 상의 주소가 아니다.

### 메인 메모리 DB와 비교
#### ✅ 1. 메인 메모리 DB(MMDB)란?

- 데이터를 **모두 메모리에 로드**하여 **디스크 I/O 없이** 수행하는 데이터베이스.
- 잘 튜닝된 **OLTP(Online Transaction Processing) DB**도 버퍼 캐시 히트율이 99% 이상이지만, 여전히 **디스크를 경유**하기 때문에 **메인 메모리 DB보다 느림**.
- 오라클은 `디스크 주소 기반`, 메인 메모리 DB는 `메모리 주소 기반`으로 접근 방식이 다르며, 이로 인해 인덱스를 통한 테이블 액세스 속도에서 큰 차이가 발생함.

#### ✅ 2. 오라클 vs. 메인 메모리 DB 인덱스 차이

|                | **오라클**                                          | **메인 메모리 DB**                        |
| -------------- | ------------------------------------------------ | ------------------------------------ |
| **데이터 저장**     | 디스크에 저장 후 버퍼 캐시로 로딩                              | 모든 데이터를 메모리에 로드                      |
| **인덱스 주소**     | 디스크 상의 **주소 정보(ROWID, DBA: Data Block Address)** | **메모리 상의 주소 정보(포인터)**                |
| **테이블 액세스 속도** | 테이블 블록이 버퍼에서 밀려나면 다시 캐싱해야 함                      | 인덱스를 통해 바로 테이블 액세스 가능                |
| **성능 차이**      | 인덱스를 거쳐 테이블 조회 시 오버헤드 발생                         | 인덱스를 거쳐도 **메모리 직접 접근**으로 속도 저하 거의 없음 |

### 인덱스 ROWID는 `우편번호` vs 메인 메모리 DB는 `전화번호`
디스크 DB는 메모리에 캐싱이 되어 있어도 주소를 찾아가기 위한 오버헤더가 심함

## 3.1.2 인덱스 클러스터링 팩터
특정 컬럼을 기준으로 같은 값의 데이터가 서로 모여 있는 정도를 의미
>> 예를 들어 일일 입출고 테이블, 일일 생산 테이블 등을 조회할 때 대부분 일자별로 조회 하므로 날짜별로 테이블에 데이터가 모여 있는 것이 좋다. 이런 것을 클러스터링 팩터가 높다고 한다.

### 클러스터링 팩터가 좋은 경우
![[Pasted image 20250203141227.png]]

### 클러스터링 팩터가 안좋은 경우
![[Pasted image 20250203141310.png]]
--> 어떻게 하면 좋게 만들 수 있을까?
Reorg : 소트하여 다시 밀어 넣는다.
### 클러스터링 팩터 효과를 못보는 경우
![[Pasted image 20250203141401.png]]


## 3.1.3 인덱스 손익분기점
![[Pasted image 20250203142755.png]]
인덱스를 사용하는 것이 항상 좋은 결과는 아니다.
그러나 OLTP 에서는 대부분 인덱스가 좋다.

### 온라인 프로그램 튜닝 vs. 배치 프로그램 튜닝
#### 온라인 프로그램 튜닝
- 소량 데이터 읽고 갱신하므로 인덱스를 효과적으로 활용
- 대부분 NL 방식
- 인덱스를 이용한 소트 연산을 생략

#### 배치 프로그래밍 튜닝
- Full Scan과 해시 조인이 효과적
- 작업을 위한 임시 테이블 생성도 고려
- 초대용량 테이블은 파티션 활용 & 병렬처리

## 3.1.4 인덱스 칼럼 추가

```sql
-- emp_x01 : deptno + job
select /*+ index(emp emp_x01) */ *
from emp
where deptno = 30
and sal >= 2000
```

![[Pasted image 20250203144318.png]]

기존인덱스에 sal 추가하면?
![[Pasted image 20250203144427.png]]
인덱스 스캔량은 그대로지만 테이블의 랜덤 액세스가 6번에서 1번으로 줄었다.

## 3.1.5 인덱스만 읽고 처리
Covered 인덱스 : 인덱스 자체에 쿼리에 필요한 컬럼을 다 넣어서 테이블 액세스를 하지 않고 인덱스만으로도 필요한 데이터를 구하는 인덱스
#### Include 인덱스
- 오라클에는 아직 없음
- 인덱스 키 외 미리 지정한 컬럼을 리프 레벨에 함께 저장(인덱스에 붙은 데이터)
- 순전히 테이블 랜덤 액세스를 줄이는 용도
- 단점은 테이블의 데이터 중복으로 용량 차지

## 3.1.6 인덱스 구조 테이블
- 오라클 IOT(Index-Organized Table), MS-SQL Server 클러스터 형(Clustered) Index
- 테이블이 인덱스 구조를 가지고 있음
- 항상 정렬 상태를 유지

>> 어떤 테이블에 쓰면 좋을까? 체인별로 예를 들어 보자.
>> 또 단점은 뭘까?
```SQL
create table index_org_t ( a number, b varchar(10)
                           , constraint index_org_t_pk primary key (a) )
organization index ;
```

## 3.1.7 클러스터 테이블
### 인덱스 클러스터 테이블
클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 구조, 한 블록에 모두 담을 수 없을 때는 새로운 블록을 할당해서 클러스터 체인으로 연결.

![[Pasted image 20250203150837.png]]

- 여러 테이블 레코드를 같은 블록에 저장 할 수도 있음(`다중 테이블 클러스터`)
- 오라클에서는 클러스터 내에 같은 키가 모여 있지만 정렬은 되어 있지 않음
- 클러스터 인덱스는 각 ROW를 가지는 것이 아니라 클러스터의 첫번째 레코드를 가르킴(위 그림에서는 3개의 레코드만 가르킴)
### 해시 클러스터 테이블
![[Pasted image 20250203150925.png]]

# 3.2 부분범위 처리 활용
## 3.2.1 부분범위 처리
- DBMS가 클라이언트에게 데이터 전송 시 일정량 씩(Array Size) 나누어 전송
- 네트워크도 디스크와 마찬가지로 시간이 오래 걸리는 I/O 이다.
- 서버 프로세스는 일정량 전송하고 추가 Fetch Call이 올 때까지 Sleep 한다.

### 정렬 조건이 있을 때 부분범위 처리
- DB 서버는 모든 데이터를 다 읽어 created 순으로 정렬을 마치고서야 클라이언트에게 전송
- 그런데 다행히 created 컬럼이 선두인 인덱스가 있으면, 부분 범위 처리가 가능
	(인덱스에 의해 자동으로 정렬이 되는 경우는 부분 범위 처리 가능)

### Array Size 조정을 통한 Fetch Call 최소화
- 대량의 데이터를 받는다면 크게 설정
- 앞쪽 일부 데이터만 Fetch 한다면 Array Size를 작게 설정
	(예: 페이징)
### 쿼리 툴에서 부분범위 처리
![[Pasted image 20250203160357.png]]
![[Pasted image 20250203160416.png]]

## 3.2.2 부분범위 처리 구현
개발 프레임워크에 미리 구현돼 있는 기능을 활용하라

## 3.2.3 OLTP 환경에서 부분범위 처리를 위한 성능 개선 원리
