	
![[Pasted image 20241203135237.png]]
# 서브쿼리 종류
- 단일 값 서브쿼리
```SQL
	SELECT employee_id, salary 
	FROM employees 
	WHERE salary > (SELECT AVG(salary) FROM employees);

```
- 다중 행 서브쿼리

```SQL
	SELECT employee_id, salary 
	FROM employees 
	WHERE department_id IN (SELECT department_id FROM departments WHERE location_id = 1400);
```

- 다중 열 서브쿼리

```SQL
	SELECT employee_id, first_name, last_name
	FROM employees 
	WHERE (department_id, job_id) IN 
	    (SELECT department_id, job_id FROM departments WHERE location_id = 1400);

```

- Exists 서브쿼리

```SQL
	SELECT employee_id, first_name 
	FROM employees 
	WHERE EXISTS (SELECT 1 FROM departments WHERE location_id = 1400);

```

# 실습 데이터
```SQL
--=====================================================================================
--                서브쿼리 이해와 성능문제 이해하기
--=====================================================================================

DROP TABLE SUBQUERY_T1 PURGE ;
DROP TABLE SUBQUERY_T2 PURGE ;
DROP TABLE SUBQUERY_T3 PURGE ;

-- SUBQUERY_T1 테이블 생성 

-- 테이블 생성
CREATE TABLE SUBQUERY_T1 AS
SELECT LEVEL AS C4, CHR(65+MOD(LEVEL,26)) AS C5, LEVEL+99999 AS C6
FROM DUAL
CONNECT BY LEVEL <= 250000 ;

-- 250,000개의 데이터를 생성 한 후 동일한 테이블 값을 6번 반복하여 복사함.

BEGIN
      FOR I IN 1..6 LOOP
           INSERT INTO SUBQUERY_T1 SELECT * FROM SUBQUERY_T1;
           COMMIT;
      END LOOP;
END;
/

-- 각 칼럼에 인덱스 생성 및 통계정보를 수집
EXEC dbms_stats.gather_table_stats(OWNNAME=>'USERS',TABNAME=>'SUBQUERY_T1',CASCADE=>TRUE,ESTIMATE_PERCENT=>100) ;

CREATE INDEX SUBQUERY_T1_IDX_01 ON SUBQUERY_T1 ( C4, C5 ) ;
CREATE INDEX SUBQUERY_T1_IDX_02 ON SUBQUERY_T1 ( C5 ) ;




-- SUBQUERY_T2 테이블 생성 

CREATE TABLE SUBQUERY_T2 AS
SELECT LEVEL AS C1, CHR(65+MOD(LEVEL,26)) AS C2, LEVEL+99999 AS C3, 
       CHR(65+MOD(LEVEL,26)) AS C4
  FROM DUAL 
CONNECT BY LEVEL <= 500000 ;

-- 각 칼럼에 인덱스 생성 및 통계정보 수집
EXEC dbms_stats.gather_table_stats(OWNNAME=>'USERS',TABNAME=>'SUBQUERY_T2',CASCADE=>TRUE,ESTIMATE_PERCENT=>100) ;


---------------------------------------------------------------------------
-- 테스트의 플랜이 다르게 나오면 인덱스 삭제 
CREATE INDEX SUBQUERY_T2_IDX_01 ON SUBQUERY_T2 ( C2, C1 ) ;
ALTER TABLE SUBQUERY_T2 ADD CONSTRAINT PK_SUQUERY_2 PRIMARY KEY (C1);
---------------------------------------------------------------------------


-- SUBQUERY_T3 테이블 생성 

CREATE TABLE SUBQUERY_T3 AS
SELECT LEVEL AS C1, CHR(65+MOD(LEVEL,26)) AS C2, LEVEL+99999 AS C3
  FROM DUAL
CONNECT BY LEVEL <= 500000 ;

-- 각 칼럼에 인덱스 생성 및 통계정보 수집
EXEC dbms_stats.gather_table_stats(OWNNAME=>'USERS',TABNAME=>'SUBQUERY_T3',CASCADE=>TRUE,ESTIMATE_PERCENT=>100) ;


---------------------------------------------------------------------------
-- 테스트의 플랜이 다르게 나오면 인덱스 삭제 
CREATE INDEX SUBQUERY_T3_IDX_01 ON SUBQUERY_T3 ( C1, C2 ) ;
ALTER TABLE SUBQUERY_T3 ADD CONSTRAINT PK_SUQUERY_3 PRIMARY KEY (C1);
---------------------------------------------------------------------------
```
# 서브쿼리의 동작방식 이해하기
## **Filter 방식**

| 구분          | 내용                                                                                                            |
| ----------- | ------------------------------------------------------------------------------------------------------------- |
| 수행순서        | Main SQL 먼저 수행, 유연한 순서 힘듦                                                                                     |
| Main SQL 건수 | - 최대 Main SQL 추출 건수 만큼 서브 쿼리 수행<br>- Main SQL 추출 건수가 적을 경우 Filter도 괜찮음                                        |
| Input 값 종류  | - Unique 할 경우 Main SQL 추출 건수 만큼 서브 수행<br>- 값의 종류가 적을 경우, 최소 값의 종류 만큼 서브 쿼리 수행<br>  (예: 평균급여 보다 많이 받는 직원 리스트 ) |



### Test1
Main SQL의 추출건수가 많고, Input 값이 Unique한 경우 (Main SQL 많고, 서브쿼리도 많다.)
- Main 건당 서브를 한 번 검색한다. 
- Main : 380,001,  Sub : 230,001
- 인덱스 없는 최악의 경우 380001 + 380001 * 230001      = 87,400,990,002 번 검색
```sql
	ALTER SESSION SET STATISTICS_LEVEL = ALL;
	
	SELECT C1, C2, C3
	FROM   SUBQUERY_T2 T2
	WHERE  C1 >= :b1 AND C1 <= :b2 -- 380001
	-- 서브쿼리에서 230,001건 추출
	AND    EXISTS (SELECT /*+ NO_UNNEST */
	                       'X'
	               FROM SUBQUERY_T1 T1
	               WHERE  T1.C4 = T2.C1);
	
	SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

-- :b1	20000
-- :b2	400000

---------------------------------------------------------------------------------------------------------------
--| Id  | Operation           | Name               | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
---------------------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT    |                    |      1 |        |    230K|00:00:02.11 |     789K|  32367 |
--|*  1 |  FILTER             |                    |      1 |        |    230K|00:00:02.11 |     789K|  32367 |
--|*  2 |   FILTER            |                    |      1 |        |    380K|00:00:00.08 |    3610 |      0 |
--|*  3 |    TABLE ACCESS FULL| SUBQUERY_T2        |      1 |    380K|    380K|00:00:00.05 |    3610 |      0 |
--|*  4 |   INDEX RANGE SCAN  | SUBQUERY_T1_IDX_01 |    380K|      2 |    230K|00:00:01.83 |     785K|  32367 |
---------------------------------------------------------------------------------------------------------------

```

### Test2
Main SQL의 추출건수가 적고, Input 값이 Unique한 경우 (Main SQL 적다)
- Main 건 당 서브를 한 번 검색한다. 
- Main : 5,  Sub : 230,001

```sql
	SELECT C1, C2, C3
	FROM   SUBQUERY_T2 T2
	WHERE  C1 >= :b1 AND C1 <= :b2 
	AND    EXISTS (SELECT --+ NO_UNNEST
	                       'X'
	               FROM SUBQUERY_T1 T1
	               WHERE  T1.C4 = T2.C1);
	
	
	SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

-- :b1	20000
-- :b2	20004


------------------------------------------------------------------------------------------------------
--| Id  | Operation           | Name               | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
------------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT    |                    |      1 |        |      5 |00:00:00.02 |    1331 |
--|*  1 |  FILTER             |                    |      1 |        |      5 |00:00:00.02 |    1331 |
--|*  2 |   FILTER            |                    |      1 |        |      5 |00:00:00.02 |    1316 |
--|*  3 |    TABLE ACCESS FULL| SUBQUERY_T2        |      1 |      6 |      5 |00:00:00.02 |    1316 |
--|*  4 |   INDEX RANGE SCAN  | SUBQUERY_T1_IDX_01 |      5 |      2 |      5 |00:00:00.01 |      15 |
------------------------------------------------------------------------------------------------------

```

### Test3
Main SQL의 추 건수가 많고, Input 값의 종류가 26가지 (A ~ Z)
- Main : 380,001,  t2.c2 값 종류 26
- Test1 보다는 작업량이 엄청 적다
```sql
	SELECT C1, C2, C3
	FROM   SUBQUERY_T2 T2
	WHERE  C1 >= :b1 AND C1 <= :b2 -- 380001
	AND    EXISTS (SELECT --+ NO_UNNEST
	                       'X'
	               FROM SUBQUERY_T1 T1
	               WHERE  T1.C5 = T2.C2);


	SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

--:b1	20000
--:b2	400000


---------------------------------------------------------------------------------------------------------------
--| Id  | Operation           | Name               | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
---------------------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT    |                    |      1 |        |    380K|00:00:00.24 |   19808 |     51 |
--|*  1 |  FILTER             |                    |      1 |        |    380K|00:00:00.24 |   19808 |     51 |
--|*  2 |   FILTER            |                    |      1 |        |    380K|00:00:00.09 |    5106 |      0 |
--|*  3 |    TABLE ACCESS FULL| SUBQUERY_T2        |      1 |    380K|    380K|00:00:00.06 |    5106 |      0 |
--|*  4 |   INDEX RANGE SCAN  | SUBQUERY_T1_IDX_02 |  14640 |      2 |  14640 |00:00:00.04 |   14702 |     51 |
---------------------------------------------------------------------------------------------------------------

```

## 조인 동작 방식
- 유연한 대처 가능 
- 조인 방법, 조인 순서 유리하게 선택
- Input이 동일한 값이 많다면 Filter 방식이 유리 할 수 있음

### Test1 : Filter 방식으로 수행 되어 성능 문제가 발생하는 SQL
```SQL
--ALTER SESSION SET STATISTICS_LEVEL = ALL;
-- Sub Query에 적절한 Index가 없어 비효율이 발생한 경우

	SELECT C1, C2, C3
	FROM   SUBQUERY_T2 T2
	WHERE  C1 >= :b1 AND C1 <= :b2 
	AND    EXISTS (SELECT /*+ NO_UNNEST */
	                       'X'
	               FROM SUBQUERY_T1 T1  -- 16,000,000 건, 인덱스 없어서 Full scan
	               WHERE  T1.C6 = T2.C3 and t1.c6 >= :b1)
	               ;
		
	SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

-- :b1	249990
-- :b2	250210

--------------------------------------------------------------------------------------------------------
--| Id  | Operation           | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
--------------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT    |             |      1 |        |     11 |00:01:30.46 |    7864K|   7862K|
--|*  1 |  FILTER             |             |      1 |        |     11 |00:01:30.46 |    7864K|   7862K|
--|*  2 |   FILTER            |             |      1 |        |    221 |00:00:00.02 |    1317 |      0 |
--|*  3 |    TABLE ACCESS FULL| SUBQUERY_T2 |      1 |     15 |    221 |00:00:00.02 |    1317 |      0 |
--|*  4 |   FILTER            |             |    221 |        |     11 |00:01:30.43 |    7863K|   7862K|
--|*  5 |    TABLE ACCESS FULL| SUBQUERY_T1 |    221 |  69297 |     11 |00:01:30.43 |    7863K|   7862K|
------------------------------------------------------------------------------------------------------
-- 
-- 1. Main쿼리에서 221건 추출
-- 2. 서브쿼리에서 16M건의 C1에 대한 인덱스 없는 T1을 221번 만큼 Full Scan해서 11건 추출

```
**해결 방안**
  1.  SUBQUERY_T1 테이블에 C6칼럼의 인덱스를 만들어도 된다.
```SQL
	create index SUBQUERY_T1_IX01 ON SUBQUERY_T1(C6);
```
  2. 1을 할 수 없는 경우라면 Hash Join Semi로 유도 하면 된다.

```SQL
	-- 2. 1을 할 수 없는 경우라면 Hash Join Semi로 유도 하면 된다.
	SELECT C1, C2, C3
	FROM   SUBQUERY_T2 T2
	WHERE  C1 >= :b1 AND C1 <= :b2 
	AND    EXISTS (SELECT /*+ UNNEST HASH_SJ */
	                       'X'
	               FROM SUBQUERY_T1 T1  -- 16,000,000 건
	               WHERE  T1.C6 = T2.C3 and t1.c6 >= :b1)
	               ;

	SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

-- :b1	249990
-- :b2	250210

-----------------------------------------------------------------------------------------------
--| Id  | Operation           | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT    |             |      1 |        |     11 |00:00:01.53 |   38728 |
--|*  1 |  FILTER             |             |      1 |        |     11 |00:00:01.53 |   38728 |
--|*  2 |   HASH JOIN SEMI    |             |      1 |     44 |     11 |00:00:01.53 |   38728 |
--|*  3 |    TABLE ACCESS FULL| SUBQUERY_T2 |      1 |    155 |    221 |00:00:00.05 |    1315 |
--|*  4 |    TABLE ACCESS FULL| SUBQUERY_T1 |      1 |   6400K|   6400K|00:00:00.65 |   37413 |
-----------------------------------------------------------------------------------------------

```



### Test2 : Main SQL 추출 건수 많고, 서브쿼리 상수 조건 효율적일 경우
```SQL
-- Main SQL 추출 건수 많고, 서브쿼리 상수 조건 효율적일 경우

	SELECT C4
	     , C5
	     , C6
	FROM   SUBQUERY_T1 T1 -- 16M건
	WHERE  C6 >= :b1
	AND    C6 <= :b2
	AND    EXISTS ( SELECT --+ NO_UNNEST
	                       'X'
	                FROM   SUBQUERY_T2 T2
	                WHERE  T2.C1 = T1.C4
	                AND    T2.C3 >= :b3
	                AND    T2.C3 <= :b4) ;
	
--:b1	1
--:b2	450210
--:b3	100000
--:b4	100004
	
	SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

-- 너무 오래 걸려서 취소함 -> A-ROW 숫자 안맞음
--------------------------------------------------------------------------------------------------------
--| Id  | Operation           | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
--------------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT    |             |      1 |        |      5 |00:00:00.01 |      25 |     28 |
--|*  1 |  FILTER             |             |      1 |        |      5 |00:00:00.01 |      25 |     28 |
--|*  2 |   FILTER            |             |      1 |        |  30358 |00:00:00.03 |      74 |     88 |
--|*  3 |    TABLE ACCESS FULL| SUBQUERY_T1 |      1 |     14M|  30358 |00:00:00.02 |      74 |     88 |
--|*  4 |   FILTER            |             |  30358 |        |      5 |00:06:24.37 |      39M|      0 |
--|*  5 |    TABLE ACCESS FULL| SUBQUERY_T2 |  30358 |      1 |      5 |00:06:24.35 |      39M|      0 |
--------------------------------------------------------------------------------------------------------


-- 문제가 뭘까? T1이 1600만건 추출되고 T2에 의해 5건 추출되는 구조
-- 2중 FOR LOOP 처럼 T2를 1600만번 FULL SCAN
```
 

 **해결 방안 1 (적절한 인덱스가 없을 경우)**
   - 조인 방식 (UNNEST)
   - Hash Join Semi(HASH JOIN SEMI)

 ```SQL
SELECT C4
     , C5
     , C6
FROM   SUBQUERY_T1 T1
WHERE  C6 >= :b1
AND    C6 <= :b2 
AND    EXISTS (SELECT --+ UNNEST HASH_SJ
                       'X'
               FROM   SUBQUERY_T2 T2
               WHERE  T2.C1 = T1.C4
               AND    T2.C3 >= :b3 
               AND    T2.C3 <= :b4)
               ;


-- UNNEST   조인 방식으로 풀어라.
-- HASH_SJ  HASH JOIN SEMI로 풀어라

SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));


--:b1	1
--:b2	450210
--:b3	100000
--:b4	100004

-------------------------------------------------------------------------------------------------
--| Id  | Operation             | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT      |             |      1 |        |    320 |00:00:02.97 |   38733 |
--|*  1 |  FILTER               |             |      1 |        |    320 |00:00:02.97 |   38733 |
--|*  2 |   HASH JOIN RIGHT SEMI|             |      1 |    990 |    320 |00:00:02.97 |   38733 |
--|*  3 |    TABLE ACCESS FULL  | SUBQUERY_T2 |      1 |     15 |      5 |00:00:00.02 |    1316 |
--|*  4 |    TABLE ACCESS FULL  | SUBQUERY_T1 |      1 |     14M|     16M|00:00:00.90 |   37417 |
-------------------------------------------------------------------------------------------------

```

** 해결방안2 (적절한 인덱스가 있을 경우)**
```SQL

SELECT --+ QB_NAME(MAIN) LEADING(T2@SUB) USE_NL(T1@MAIN)
       C4
     , C5
     , C6
FROM   SUBQUERY_T1 T1
WHERE  C6 >= :b1
AND    C6 <= :b2
AND    EXISTS (SELECT --+ UNNEST QB_NAME(SUB)
                       'X'
                FROM   SUBQUERY_T2 T2
                WHERE  T2.C1 = T1.C4
                AND    T2.C3 >= :b3
                AND    T2.C3 <= :b4) ;
 

-- QB_NAME  쿼리블럭의 이름을 지정
-- LEADING  순서 지정 (SUB 블럭의 T2 테이블을 LEADING 테이블로)
-- USE_NL   NESTED LOOP 사용


SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

--:b1	1
--:b2	450210
--:b3	100000
--:b4	100004

----------------------------------------------------------------------------------------------------------------
--| Id  | Operation                     | Name               | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
----------------------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT              |                    |      1 |        |    320 |00:00:00.03 |    1653 |
--|*  1 |  FILTER                       |                    |      1 |        |    320 |00:00:00.03 |    1653 |
--|   2 |   NESTED LOOPS                |                    |      1 |        |    320 |00:00:00.03 |    1653 |
--|   3 |    NESTED LOOPS               |                    |      1 |    316 |    320 |00:00:00.03 |    1333 |
--|   4 |     SORT UNIQUE               |                    |      1 |      5 |      5 |00:00:00.03 |    1315 |
--|*  5 |      TABLE ACCESS FULL        | SUBQUERY_T2        |      1 |      5 |      5 |00:00:00.03 |    1315 |
--|*  6 |     INDEX RANGE SCAN          | SUBQUERY_T1_IDX_01 |      5 |     63 |    320 |00:00:00.01 |      18 |
--|*  7 |    TABLE ACCESS BY INDEX ROWID| SUBQUERY_T1        |    320 |     63 |    320 |00:00:00.01 |     320 |
----------------------------------------------------------------------------------------------------------------

-- SORT UNIQUE의 이유 - 조인으로 변경되어 추출결과 건수가 틀려지는것을 방지 위해 중복값 제거

```

# 서브쿼리 실행계획 제어


# 테이블 2-1. 서브쿼리의 실행계획을 조절하는 힌트들

| Hint 명              | 설명                                                                                                     |
| ------------------- | ------------------------------------------------------------------------------------------------------ |
| NO_UNNEST           | 서브쿼리를 **FILTER 동작방식**으로 처리하고 싶을 경우, 서브쿼리에 NO_UNNEST 힌트를 사용하면 된다.                                       |
| UNNEST              | FILTER 동작방식을 선택하지 않고 **조인 동작방식**으로 처리하고자 할 때, 서브쿼리에 UNNEST 힌트를 사용하면 된다.                                |
| NL_SJ               | EXISTS 나 IN 조건을 사용할 경우 서브쿼리에 UNNEST 와 함께 NL_SJ 힌트를 사용하면, **NESTED LOOPS JOIN SEMI** 로 처리하도록 유도         |
| HASH_SJ             | EXISTS 나 IN 조건을 사용할 경우 서브쿼리에 UNNEST 와 함께 HASH_SJ 힌트를 부여하면 **HASH JOIN SEMI** 로 처리하도록 제어                |
| NL_AJ               | NOT EXISTS 나 NOT IN 조건을 사용할 경우 서브쿼리에 UNNEST 와 함께 NL_AJ 힌트를 사용하면, **NESTED LOOPS JOIN ANTI** 로 처리하도록 제어 |
| HASH_AJ             | NOT EXISTS 나 NOT IN 조건을 사용할 경우 서브쿼리에 UNNEST 와 함께 HASH_AJ 힌트를 사용하면 **HASH JOIN ANTI** 로 처리하도록 제어        |
| ORDERED             | F**ROM 절에 나열된 순서대로 수행**하도록 조인 순서를 정하는 힌트이다. 하지만 **서브쿼리가 존재한다면 서브쿼리가 가장 먼저 수행**된다.                      |
| QB_NAME             | QUERY BLOCK 의 이름을 지정한다.                                                                                |
| SWAP_JOIN_INPUTS    | HASH JOIN 시 SWAP_JOIN_INPUTS 힌트를 사용하면 조인 순서를 바꿀 수 있다.                                                  |
| NO_SWAP_JOIN_INPUTS | HASH JOIN 시 조인 순서가 바뀌는 경우, 이를 강제적으로 바꾸지 못하도록 제어할 수 있다.                                                 |
| PUSH_SUBQ           | 서브쿼리가 먼저 수행되도록 제어하는 힌트이다.                                                                              |



### 1) 서브쿼리를 Filter 동작으로 수행
```SQL
SELECT C4
     , C5
     , C6
FROM   SUBQUERY_T1 T1
WHERE  C6 >= :b1
AND    C6 <= :b2 
AND    EXISTS (SELECT --+ NO_UNNEST
                       'X'
               FROM   SUBQUERY_T2 T2
               WHERE  T2.C1 = T1.C4
               AND    T2.C3 >= :b3 
               AND    T2.C3 <= :b4)
               ;
               
SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));               

--:b1	1
--:b2	450210
--:b3	100000
--:b4	100004

-- 너무 오래 걸려서 취소
--------------------------------------------------------------------------------------------------------
--| Id  | Operation           | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
--------------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT    |             |      1 |        |      5 |00:00:00.01 |      19 |     28 |
--|*  1 |  FILTER             |             |      1 |        |      5 |00:00:00.01 |      19 |     28 |
--|*  2 |   FILTER            |             |      1 |        |  12159 |00:00:00.01 |      31 |     43 |
--|*  3 |    TABLE ACCESS FULL| SUBQUERY_T1 |      1 |     16M|  12159 |00:00:00.01 |      31 |     43 |
--|*  4 |   FILTER            |             |  12159 |        |      5 |00:02:30.13 |      15M|      0 |
--|*  5 |    TABLE ACCESS FULL| SUBQUERY_T2 |  12159 |      1 |      5 |00:02:30.12 |      15M|      0 |
--------------------------------------------------------------------------------------------------------

```

### 2)  서브쿼리를 Nested Loops Semi Join으로 수행
```SQL
SELECT C4
     , C5
     , C6
FROM   SUBQUERY_T1 T1
WHERE  C6 >= :b1
AND    C6 <= :b2 
AND    EXISTS (SELECT --+ UNNEST NL_SJ
                       'X'
               FROM   SUBQUERY_T2 T2
               WHERE  T2.C1 = T1.C4
               AND    T2.C3 >= :b3 
               AND    T2.C3 <= :b4)
               ;
               
               
SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

--:b1	1
--:b2	450210
--:b3	100000
--:b4	100004

-- 너무 오래 걸려서 취소
--------------------------------------------------------------------------------------------------------
--| Id  | Operation           | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
--------------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT    |             |      1 |        |      5 |00:00:00.01 |      19 |     28 |
--|*  1 |  FILTER             |             |      1 |        |      5 |00:00:00.01 |      19 |     28 |
--|   2 |   NESTED LOOPS SEMI |             |      1 |    379 |      5 |00:00:00.01 |      19 |     28 |
--|*  3 |    TABLE ACCESS FULL| SUBQUERY_T1 |      1 |     16M|   3369 |00:00:00.01 |      11 |     28 |
--|*  4 |    TABLE ACCESS FULL| SUBQUERY_T2 |   3369 |      1 |      5 |00:00:42.65 |    4422K|      0 |
--------------------------------------------------------------------------------------------------------

```

### 3) 서브쿼리를 Hash Join Semi Join으로 수행,  서브쿼리를 Main SQL 보다 먼저 수행
```SQL
--  조인방식, Hash Semi Join 방식, 서브 쿼리를 Main SQL 테이블 보다 먼저 수행되도록 제어
SELECT --+ QB_NAME(MAIN) LEADING(T2@SUB)
       C4
     , C5
     , C6
FROM   SUBQUERY_T1 T1
WHERE  C6 >= :b1
AND    C6 <= :b2 
AND    EXISTS (SELECT --+ QB_NAME(SUB) UNNEST HASH_SJ
                       'X'
               FROM   SUBQUERY_T2 T2
               WHERE  T2.C1 = T1.C4
               AND    T2.C3 >= :b3 
               AND    T2.C3 <= :b4)
               ;
               
               
SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

--:b1	1
--:b2	450210
--:b3	100000
--:b4	100004

-----------------------------------------------------------------------------------------------
--| Id  | Operation           | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT    |             |      1 |        |    320 |00:00:04.20 |   38727 |
--|*  1 |  FILTER             |             |      1 |        |    320 |00:00:04.20 |   38727 |
--|*  2 |   HASH JOIN SEMI    |             |      1 |    379 |    320 |00:00:04.20 |   38727 |
--|*  3 |    TABLE ACCESS FULL| SUBQUERY_T1 |      1 |     16M|     16M|00:00:01.30 |   37412 |
--|*  4 |    TABLE ACCESS FULL| SUBQUERY_T2 |      1 |      5 |      5 |00:00:00.01 |    1315 |
-----------------------------------------------------------------------------------------------

/*
안되는 이유 
  - 서브 쿼리 기본적으로 outer 조인
  - HASH OUTER JOIN 은 고정된 조인 순서 (MAIN -> SUB)
*/





SELECT C4
     , C5
     , C6
FROM   SUBQUERY_T1 T1
WHERE  C6 >= :b1
AND    C6 <= :b2
AND    EXISTS (SELECT --+ UNNEST  HASH_SJ SWAP_JOIN_INPUTS(T2)
                       'X'
                FROM   SUBQUERY_T2 T2
                WHERE  T2.C1 = T1.C4
                AND    T2.C3 >= :b3
                AND    T2.C3 <= :b4) ;
 
 
 SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));
 
--:b1	1
--:b2	450210
--:b3	100000
--:b4	100004

 
-------------------------------------------------------------------------------------------------
--| Id  | Operation             | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT      |             |      1 |        |    320 |00:00:03.37 |   38731 |
--|*  1 |  FILTER               |             |      1 |        |    320 |00:00:03.37 |   38731 |
--|*  2 |   HASH JOIN RIGHT SEMI|             |      1 |    379 |    320 |00:00:03.37 |   38731 |
--|*  3 |    TABLE ACCESS FULL  | SUBQUERY_T2 |      1 |      5 |      5 |00:00:00.04 |    1315 |
--|*  4 |    TABLE ACCESS FULL  | SUBQUERY_T1 |      1 |     16M|     16M|00:00:01.26 |   37416 |
-------------------------------------------------------------------------------------------------
```

### 4) 서브쿼리를 Hash Semi Join으로 수행, Main SQL을 먼저 수행
```SQL
SELECT 
       C4
     , C5
     , C6
FROM   SUBQUERY_T1 T1
WHERE  C6 >= :b1
AND    C6 <= :b2 
AND    EXISTS (SELECT --+ UNNEST HASH_SJ NO_SWAP_JOIN_INPUTS(T2)
                       'X'
               FROM   SUBQUERY_T2 T2
               WHERE  T2.C1 = T1.C4
               AND    T2.C3 >= :b3 
               AND    T2.C3 <= :b4)
               ;
               
               
SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

--:b1	1
--:b2	450210
--:b3	100000
--:b4	100004

-----------------------------------------------------------------------------------------------
--| Id  | Operation           | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT    |             |      1 |        |    320 |00:00:04.20 |   38727 |
--|*  1 |  FILTER             |             |      1 |        |    320 |00:00:04.20 |   38727 |
--|*  2 |   HASH JOIN SEMI    |             |      1 |    379 |    320 |00:00:04.20 |   38727 |
--|*  3 |    TABLE ACCESS FULL| SUBQUERY_T1 |      1 |     16M|     16M|00:00:01.30 |   37412 |
--|*  4 |    TABLE ACCESS FULL| SUBQUERY_T2 |      1 |      5 |      5 |00:00:00.01 |    1315 |
-----------------------------------------------------------------------------------------------


```

### 5) Nested Loop Join으로 수행, 서브쿼리부터 수행
```SQL
SELECT --+ QB_NAME(MAIN) LEADING(T2@SUB) USE_NL(T1@MAIN)
       C4
     , C5
     , C6
FROM   SUBQUERY_T1 T1
WHERE  C6 >= :b1
AND    C6 <= :b2 
AND    EXISTS (SELECT --+ QB_NAME(SUB) UNNEST
                       'X'
               FROM   SUBQUERY_T2 T2
               WHERE  T2.C1 = T1.C4
               AND    T2.C3 >= :b3 
               AND    T2.C3 <= :b4)
               ;
               
               
SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

----------------------------------------------------------------------------------------------------------------
--| Id  | Operation                     | Name               | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
----------------------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT              |                    |      1 |        |    320 |00:00:00.03 |    1653 |
--|*  1 |  FILTER                       |                    |      1 |        |    320 |00:00:00.03 |    1653 |
--|   2 |   NESTED LOOPS                |                    |      1 |        |    320 |00:00:00.03 |    1653 |
--|   3 |    NESTED LOOPS               |                    |      1 |    316 |    320 |00:00:00.03 |    1333 |
--|   4 |     SORT UNIQUE               |                    |      1 |      5 |      5 |00:00:00.03 |    1315 |
--|*  5 |      TABLE ACCESS FULL        | SUBQUERY_T2        |      1 |      5 |      5 |00:00:00.03 |    1315 |
--|*  6 |     INDEX RANGE SCAN          | SUBQUERY_T1_IDX_01 |      5 |     63 |    320 |00:00:00.01 |      18 |
--|*  7 |    TABLE ACCESS BY INDEX ROWID| SUBQUERY_T1        |    320 |     63 |    320 |00:00:00.01 |     320 |
----------------------------------------------------------------------------------------------------------------

```

### 6) Hash Join으로 처리, 서브쿼리부터 수행
```SQL
SELECT --+ QB_NAME(MAIN) LEADING(T2@SUB) USE_HASH(T1@MAIN)
       C4
     , C5
     , C6
FROM   SUBQUERY_T1 T1
WHERE  C6 >= :b1
AND    C6 <= :b2 
AND    EXISTS (SELECT --+ QB_NAME(SUB) UNNEST
                       'X'
               FROM   SUBQUERY_T2 T2
               WHERE  T2.C1 = T1.C4
               AND    T2.C3 >= :b3 
               AND    T2.C3 <= :b4)
               ;
               
               
SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

------------------------------------------------------------------------------------------------
--| Id  | Operation            | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT     |             |      1 |        |    320 |00:00:03.37 |   38731 |
--|*  1 |  FILTER              |             |      1 |        |    320 |00:00:03.37 |   38731 |
--|*  2 |   HASH JOIN          |             |      1 |    316 |    320 |00:00:03.37 |   38731 |
--|   3 |    SORT UNIQUE       |             |      1 |      5 |      5 |00:00:00.01 |    1315 |
--|*  4 |     TABLE ACCESS FULL| SUBQUERY_T2 |      1 |      5 |      5 |00:00:00.01 |    1315 |
--|*  5 |    TABLE ACCESS FULL | SUBQUERY_T1 |      1 |     16M|     16M|00:00:01.26 |   37416 |
------------------------------------------------------------------------------------------------
 
 
 
 

-- SQL3의 결과 (유사함)
-------------------------------------------------------------------------------------------------
--| Id  | Operation             | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT      |             |      1 |        |    320 |00:00:03.37 |   38731 |
--|*  1 |  FILTER               |             |      1 |        |    320 |00:00:03.37 |   38731 |
--|*  2 |   HASH JOIN RIGHT SEMI|             |      1 |    379 |    320 |00:00:03.37 |   38731 |
--|*  3 |    TABLE ACCESS FULL  | SUBQUERY_T2 |      1 |      5 |      5 |00:00:00.04 |    1315 |
--|*  4 |    TABLE ACCESS FULL  | SUBQUERY_T1 |      1 |     16M|     16M|00:00:01.26 |   37416 |
-------------------------------------------------------------------------------------------------
```

### 7) NOT Exists, Nested Loops Anti Join으로 수행
```SQL
SELECT C4
     , C5
     , C6
FROM   SUBQUERY_T1 T1
WHERE  C6 >= :b1
AND    C6 <= :b2 
AND    NOT EXISTS (SELECT --+ UNNEST NL_AJ
                           'X'
                   FROM   SUBQUERY_T2 T2
                   WHERE  T2.C1 = T1.C4
                   AND    T2.C3 >= :b3 
                   AND    T2.C3 <= :b4)
               ;
               
               
SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

-- 오래 걸려서 취소
--------------------------------------------------------------------------------------------------------
--| Id  | Operation           | Name        | Starts | E-Rows | A-Rows |   A-Time   | Buffers | Reads  |
--------------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT    |             |      1 |        |   1452 |00:00:18.20 |    1909K|     28 |
--|*  1 |  FILTER             |             |      1 |        |   1452 |00:00:18.20 |    1909K|     28 |
--|   2 |   NESTED LOOPS ANTI |             |      1 |     15M|   1452 |00:00:18.20 |    1909K|     28 |
--|*  3 |    TABLE ACCESS FULL| SUBQUERY_T1 |      1 |     16M|   1458 |00:00:00.01 |      21 |     28 |
--|*  4 |    TABLE ACCESS FULL| SUBQUERY_T2 |   1458 |      1 |      5 |00:00:18.20 |    1909K|      0 |
--------------------------------------------------------------------------------------------------------

```

### 8) NOT Exists, Hash Join Anti로 수행
```SQL
explain plan for
SELECT C4
     , C5
     , C6
FROM   SUBQUERY_T1 T1
WHERE  C6 >= :b1
AND    C6 <= :b2 
AND    NOT EXISTS (SELECT --+ UNNEST HASH_AJ
                           'X'
                   FROM   SUBQUERY_T2 T2
                   WHERE  T2.C1 = T1.C4
                   AND    T2.C3 >= :b3 
                   AND    T2.C3 <= :b4)
               ;
               
--SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));
               
SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY());
-- 원래 플랜 보는 것이 동작을 안함
---------------------------------------------------------------------------------------
--| Id  | Operation             | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT      |             | 38649 |   830K| 10733   (2)| 00:02:09 |
--|*  1 |  FILTER               |             |       |       |            |          |
--|*  2 |   HASH JOIN RIGHT ANTI|             | 38649 |   830K| 10733   (2)| 00:02:09 |
--|*  3 |    TABLE ACCESS FULL  | SUBQUERY_T2 |  1250 | 12500 |   370   (2)| 00:00:05 |
--|*  4 |    TABLE ACCESS FULL  | SUBQUERY_T1 | 40000 |   468K| 10362   (2)| 00:02:05 |
---------------------------------------------------------------------------------------

```

### 9) 서브쿼리 먼주 수행, Nested Loop Join으로 수행
```SQL
-- 변경전
SELECT A.*
FROM   EMP A
WHERE  EMPNO IN (SELECT MAX(EMPNO) 
                 FROM   EMP X 
                 GROUP BY DEPTNO);
                 
SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

-----------------------------------------------------------------------------------------------------
--| Id  | Operation                    | Name     | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT             |          |      1 |        |      3 |00:00:00.01 |      10 |
--|   1 |  MERGE JOIN                  |          |      1 |      3 |      3 |00:00:00.01 |      10 |
--|   2 |   TABLE ACCESS BY INDEX ROWID| EMP      |      1 |     12 |     12 |00:00:00.01 |       4 |
--|   3 |    INDEX FULL SCAN           | PK_EMP   |      1 |     12 |     12 |00:00:00.01 |       2 |
--|*  4 |   SORT JOIN                  |          |     12 |      3 |      3 |00:00:00.01 |       6 |
--|   5 |    VIEW                      | VW_NSO_1 |      1 |      3 |      3 |00:00:00.01 |       6 |
--|   6 |     HASH GROUP BY            |          |      1 |      3 |      3 |00:00:00.01 |       6 |
--|   7 |      TABLE ACCESS FULL       | EMP      |      1 |     12 |     12 |00:00:00.01 |       6 |
-----------------------------------------------------------------------------------------------------



-- 변경 후 1
SELECT --+ QB_NAME(MAIN) LEADING(X@SUB) USE_NL(A@MAIN)
       A.*
FROM   EMP A
WHERE  EMPNO IN (SELECT --+ UNNEST QB_NAME(SUB)
                        MAX(EMPNO) 
                 FROM   EMP X 
                 GROUP BY DEPTNO);
                 
SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));


-----------------------------------------------------------------------------------------------------
--| Id  | Operation                    | Name     | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT             |          |      1 |        |      3 |00:00:00.01 |      10 |
--|   1 |  MERGE JOIN                  |          |      1 |      3 |      3 |00:00:00.01 |      10 |
--|   2 |   TABLE ACCESS BY INDEX ROWID| EMP      |      1 |     12 |     12 |00:00:00.01 |       4 |
--|   3 |    INDEX FULL SCAN           | PK_EMP   |      1 |     12 |     12 |00:00:00.01 |       2 |
--|*  4 |   SORT JOIN                  |          |     12 |      3 |      3 |00:00:00.01 |       6 |
--|   5 |    VIEW                      | VW_NSO_1 |      1 |      3 |      3 |00:00:00.01 |       6 |
--|   6 |     HASH GROUP BY            |          |      1 |      3 |      3 |00:00:00.01 |       6 |
--|   7 |      TABLE ACCESS FULL       | EMP      |      1 |     12 |     12 |00:00:00.01 |       6 |
-----------------------------------------------------------------------------------------------------

-- 힌트가 무시되었다. 옵티마이저가 이런짓을 한다.


-- 변경 후 2
SELECT --+ ORDERED USE_NL(A)
       A.*
FROM   EMP A
WHERE  EMPNO IN (SELECT --+ UNNEST
                        MAX(EMPNO) 
                 FROM   EMP X 
                 GROUP BY DEPTNO);
                 
SELECT * FROM   TABLE(DBMS_XPLAN.DISPLAY_CURSOR(SQL_ID=>NULL, FORMAT=>'ALLSTATS LAST'));

-----------------------------------------------------------------------------------------------------
--| Id  | Operation                    | Name     | Starts | E-Rows | A-Rows |   A-Time   | Buffers |
-----------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT             |          |      1 |        |      3 |00:00:00.01 |      11 |
--|   1 |  NESTED LOOPS                |          |      1 |        |      3 |00:00:00.01 |      11 |
--|   2 |   NESTED LOOPS               |          |      1 |      3 |      3 |00:00:00.01 |       8 |
--|   3 |    VIEW                      | VW_NSO_1 |      1 |      3 |      3 |00:00:00.01 |       6 |
--|   4 |     HASH GROUP BY            |          |      1 |      3 |      3 |00:00:00.01 |       6 |
--|   5 |      TABLE ACCESS FULL       | EMP      |      1 |     12 |     12 |00:00:00.01 |       6 |
--|*  6 |    INDEX UNIQUE SCAN         | PK_EMP   |      3 |      1 |      3 |00:00:00.01 |       2 |
--|   7 |   TABLE ACCESS BY INDEX ROWID| EMP      |      3 |      1 |      3 |00:00:00.01 |       3 |
-----------------------------------------------------------------------------------------------------

-- 이것은 왜 될까?
-- 옵티마이저가 서브쿼리를 인라인 뷰로 변경할 때 FROM절 가장 앞에 위치 시킴
-- ORDERED 힌트가 FROM절 나열 순서대로 조인
 

```

# MINUS 대신 NOT EXISTS

## MINUS, NOT EXISTS 비교

| 비교 대상  | MINUS                                                                                                         | NOT EXISTS                                                                    |
| ------ | ------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| 수행 방식  | 1. 테이블 A에서 데이터  추출<br>2. 추출된 데이터 SORT<br>3. 테이블 B에서 데이터 추출<br>4. 추출된 데이터 SORT 연산<br>5. 2번과 4번 데이터 비교 후 데이터 추출 | 1. 테이블 A에서 데이터 추출<br>2. 1번에서 추출한 데이터와 서브쿼리 테이블 <br>     B 데이터와 비교 후 최종 데이터 추출 |
| 수행 순서  | 고정 (A --> B)                                                                                                  | A --> B OR B --> A                                                            |
| SQL 성능 | 1. 테이블 A, 테이블 B에 대해 해당 되는 <br>모든 데이터 추출 (필요 이상 추출, 성능 저하)<br>2. 각각 테이블을 SORT 연산 수행 (성능 저하)                    | 1. 테이블 A의 추출 데이터를 이용한<br>B테이블의 인덱스 스캔 가능(조인 연결 키)<br>2. 테이블 SORT 연산 없음        |


### MINUS
```SQL
ALTER SESSION SET STATISTICS_LEVEL=ALL ;

SELECT c1, c2, c3
FROM   SUBQUERY_T2
WHERE  c2 = :b1
AND    c1 between :b2 and :b3
MINUS
SELECT c4, c5, c6
FROM   SUBQUERY_T1
;

			
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL ,NULL, 'ALLSTATS LAST -rows '));	

-- :b1 = 'A'
-- :b2 = 200000
-- :b3 = 300000
				  

---------------------------------------------------------------------------------------
--| Id  | Operation            | Name        | Starts | A-Rows |   A-Time   | Buffers |
---------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT     |             |      1 |   1923 |00:00:14.58 |   38745 |
--|   1 |  MINUS               |             |      1 |   1923 |00:00:14.58 |   38745 |
--|   2 |   SORT UNIQUE        |             |      1 |   3846 |00:00:00.02 |    1316 |
--|*  3 |    FILTER            |             |      1 |   3846 |00:00:00.01 |    1316 |
--|*  4 |     TABLE ACCESS FULL| SUBQUERY_T2 |      1 |   3846 |00:00:00.01 |    1316 |
--|   5 |   SORT UNIQUE        |             |      1 |    250K|00:00:14.53 |   37429 |
--|   6 |    TABLE ACCESS FULL | SUBQUERY_T1 |      1 |     16M|00:00:02.40 |   37429 |
---------------------------------------------------------------------------------------


```

### NOT EXISTS
```SQL
ALTER SESSION SET STATISTICS_LEVEL=ALL ;

SELECT c1, c2, c3
FROM   SUBQUERY_T2 t2
WHERE  c2 = :b1
AND    c1 between :b2 and :b3
AND    NOT EXISTS ( SELECT c4, c5, c6
					FROM   SUBQUERY_T1 t1
					WHERE  t1.c4 = t2.c1
					AND    t1.c5 = t2.c2
					AND    t1.c6 = t2.c3)

;

			
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL ,NULL, 'ALLSTATS LAST -rows '));	

-- :b1 = 'A'
-- :b2 = 200000
-- :b3 = 300000
				  

----------------------------------------------------------------------------------------------------------------
--| Id  | Operation                     | Name               | Starts | A-Rows |   A-Time   | Buffers | Reads  |
----------------------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT              |                    |      1 |     50 |00:00:00.03 |    4641 |   2528 |
--|*  1 |  FILTER                       |                    |      1 |     50 |00:00:00.03 |    4641 |   2528 |
--|   2 |   NESTED LOOPS ANTI           |                    |      1 |     50 |00:00:00.03 |    4641 |   2528 |
--|*  3 |    TABLE ACCESS FULL          | SUBQUERY_T2        |      1 |   1973 |00:00:00.01 |     664 |    468 |
--|*  4 |    TABLE ACCESS BY INDEX ROWID| SUBQUERY_T1        |   1973 |   1923 |00:00:00.02 |    3977 |   2060 |
--|*  5 |     INDEX RANGE SCAN          | SUBQUERY_T1_IDX_01 |   1973 |   1923 |00:00:00.02 |    3859 |   1942 |
----------------------------------------------------------------------------------------------------------------

```

# 조인 대신 서브쿼리를 활용하자
## 개선 전
```SQL

SELECT /*+ LEADING(T2 T1 T3) USE_NL(T2 T1 T3) */
		DISTINCT t2.c1, t2.c2, t3.c3
FROM SUBQUERY_T2 T2,
     SUBQUERY_T1 T1,
     SUBQUERY_T3 T3
WHERE t2.c2 = :b1
AND   t2.c1 >= :b2
AND   t2.c1 <= :b3
AND   t2.c1 = t1.c4
AND   t2.c2 = t1.c5
AND   t1.c4 = t3.c1
AND   t1.c5 = t3.c2
;

			
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL ,NULL, 'ALLSTATS LAST -rows '));	

-------------------------------------------------------------------------------------------------
--| Id  | Operation               | Name               | Starts | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT        |                    |      1 |   1923 |00:00:12.32 |    2272K|
--|   1 |  HASH UNIQUE            |                    |      1 |   1923 |00:00:12.32 |    2272K|
--|   2 |   NESTED LOOPS          |                    |      1 |   1923 |00:00:12.32 |    2272K|
--|*  3 |    HASH JOIN            |                    |      1 |   1923 |00:00:00.18 |    9368 |
--|   4 |     JOIN FILTER CREATE  | :BF0000            |      1 |   3846 |00:00:00.02 |    1315 |
--|*  5 |      TABLE ACCESS FULL  | SUBQUERY_T2        |      1 |   3846 |00:00:00.02 |    1315 |
--|   6 |     VIEW                | VW_DTP_BA8ECEFB    |      1 |   1923 |00:00:00.16 |    8053 |
--|   7 |      HASH UNIQUE        |                    |      1 |   1923 |00:00:00.16 |    8053 |
--|*  8 |       FILTER            |                    |      1 |    123K|00:00:00.14 |    8053 |
--|   9 |        JOIN FILTER USE  | :BF0000            |      1 |    123K|00:00:00.13 |    8053 |
--|* 10 |         INDEX RANGE SCAN| SUBQUERY_T1_IDX_01 |      1 |    123K|00:00:00.12 |    8053 |
--|* 11 |    TABLE ACCESS FULL    | SUBQUERY_T3        |   1923 |   1923 |00:00:12.13 |    2263K|
-------------------------------------------------------------------------------------------------

/*
	1. 조인 순서 T2 --> T1 --> T3
	2. 데이터 추출 T2, T3 (T1은 없음)
	3. T1이 없어도 T2와 T3 연결이 가능 (T2.C1 = T3.C1 AND T2.C2 = T3.C2)
	4. T1 의 역할은 무엇인가?

	문제점
	1. T2의 칼럼은 Unique 하다.
	2. T1의 C4 칼럼은 Unique 하지 않다.
	3. T3의 C1칼럼과 C2 칼럼은 Unique 하다.
	4. 그러므로 DISTINCT는 T2를 조인했을 때 데이터 중복이 발생한 것이다.
	5. T2에서 3846건, T1에서 123072건, 조인하여 123072건으로 데이터 증가

	책의 내용
	Rows    Row Source OPERATION
	------  ------------------------------------------------------------------
	1923    HASH UNIQUE (cr=254597 pr=1893 pw=0 time=7250803 us)
	123072   FILTER (cr=254597 pr=1893 pw=0 time=282167079 us)
	123072    TABLE ACCESS BY INDEX ROWID SUBQUERY_T3 (cr=254597 pr=1893 ...)
	246145     NESTED LOOPS (cr=254479 pr=1775 ...)
	123072      NESTED LOOPS (cr=8013 pr=1646 ...)
	3846         INDEX RANGE SCAN SUBQUERY_T2_IDX_01 (cr=12 pr=12 ...)
	123072       INDEX RANGE SCAN SUBQUERY_T1_IDX_01 (cr=8001 pr=1634 ...)
	123072      INDEX RANGE SCAN SUBQUERY_T3_IDX_01 (cr=246466 pr=129 ...)


*/


```

## 개선 후
```SQL

SELECT --+ LEADING(T2 T1@SUB T3) USE_NL(T2 T1@SUB T3)
	   t2.c1, t2.c2, t3.c3
FROM SUBQUERY_T2 T2,
     SUBQUERY_T3 T3
WHERE t2.c2 = :b1
AND   t2.c1 >= :b2
AND   t2.c1 <= :b3
AND   t2.c1 = t3.c1
AND   t2.c2 = t3.c2
AND   EXISTS (SELECT --+ QB_NAME(SUB)
					 'X'
			  FROM   SUBQUERY_T1 T1
			  WHERE  t1.c4 = t2.c1
			  AND    t1.c5 = t2.c2)
;


			
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR(NULL ,NULL, 'ALLSTATS LAST -rows '));	

-- :b1 = 'A'
-- :b2 = 200000
-- :b3 = 300000

-- 인덱스가 있는 경우 T2의 추출 건수가 많지 않아 USE_NL을 사용하는 것이 좋다.
-------------------------------------------------------------------------------------------------------
--| Id  | Operation                     | Name               | Starts | A-Rows |   A-Time   | Buffers |
-------------------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT              |                    |      1 |   1923 |00:00:00.02 |    5595 |
--|*  1 |  FILTER                       |                    |      1 |   1923 |00:00:00.02 |    5595 |
--|   2 |   NESTED LOOPS                |                    |      1 |   1923 |00:00:00.02 |    5595 |
--|   3 |    NESTED LOOPS               |                    |      1 |   1923 |00:00:00.01 |    5441 |
--|   4 |     NESTED LOOPS SEMI         |                    |      1 |   1923 |00:00:00.01 |    3947 |
--|*  5 |      INDEX RANGE SCAN         | SUBQUERY_T2_IDX_01 |      1 |   3846 |00:00:00.01 |      50 |
--|*  6 |      INDEX RANGE SCAN         | SUBQUERY_T1_IDX_01 |   3846 |   1923 |00:00:00.01 |    3897 |
--|*  7 |     INDEX RANGE SCAN          | SUBQUERY_T3_IDX_01 |   1923 |   1923 |00:00:00.01 |    1494 |
--|   8 |    TABLE ACCESS BY INDEX ROWID| SUBQUERY_T3        |   1923 |   1923 |00:00:00.01 |     154 |
-------------------------------------------------------------------------------------------------------

-- 인덱스가 없으면 USE_NL을 사용하지 않는 것이 좋다.
----------------------------------------------------------------------------------------------
--| Id  | Operation            | Name               | Starts | A-Rows |   A-Time   | Buffers |
----------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT     |                    |      1 |   1923 |00:00:23.59 |    4531K|
--|*  1 |  FILTER              |                    |      1 |   1923 |00:00:23.59 |    4531K|
--|   2 |   NESTED LOOPS SEMI  |                    |      1 |   1923 |00:00:23.59 |    4531K|
--|   3 |    NESTED LOOPS      |                    |      1 |   3846 |00:00:23.57 |    4528K|
--|*  4 |     TABLE ACCESS FULL| SUBQUERY_T2        |      1 |   3846 |00:00:00.02 |    1335 |
--|*  5 |     TABLE ACCESS FULL| SUBQUERY_T3        |   3846 |   3846 |00:00:23.55 |    4526K|
--|*  6 |    INDEX RANGE SCAN  | SUBQUERY_T1_IDX_01 |   3846 |   1923 |00:00:00.01 |    3878 |
----------------------------------------------------------------------------------------------

-- 인덱스가 없는 경우에도 힌트를 부여하지 않으면 적절하게 옵티마이저가 잘 결정한다.
-- 그래도 느리다면 인덱스 생성을 하자.
----------------------------------------------------------------------------------------------
--| Id  | Operation            | Name               | Starts | A-Rows |   A-Time   | Buffers |
----------------------------------------------------------------------------------------------
--|   0 | SELECT STATEMENT     |                    |      1 |   1923 |00:00:00.02 |    6390 |
--|*  1 |  FILTER              |                    |      1 |   1923 |00:00:00.02 |    6390 |
--|   2 |   NESTED LOOPS SEMI  |                    |      1 |   1923 |00:00:00.02 |    6390 |
--|*  3 |    HASH JOIN         |                    |      1 |   3846 |00:00:00.02 |    2512 |
--|*  4 |     TABLE ACCESS FULL| SUBQUERY_T2        |      1 |   3846 |00:00:00.01 |    1315 |
--|*  5 |     TABLE ACCESS FULL| SUBQUERY_T3        |      1 |   3846 |00:00:00.01 |    1197 |
--|*  6 |    INDEX RANGE SCAN  | SUBQUERY_T1_IDX_01 |   3846 |   1923 |00:00:00.01 |    3878 |
----------------------------------------------------------------------------------------------

```

